<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2D discerete Fourier Transformation Visualization</title>
<style>
  :root{
    --bg1:#0f1020;--bg2:#191a2b;--fg:#e7e8f2;--muted:#a9adc2;--accent:#7c9cff;--accent2:#8ef0ff;
    --bg-gradient1:#2a2b47;--bg-gradient2:#1d2b55;
    --controls-bg1:#111225;--controls-bg2:#0f1122;
    --card-bg1:#0f1022;--card-bg2:#0b0d1b;--card-border:#1c1e39;
    --input-bg:#0e1130;--input-border:#2a2d55;
    --control-bg:#0c0e1d;--control-border:#20223f;
    --toolbar-bg1:#101126;--toolbar-bg2:#0b0c1f;--toolbar-border:#1f2140;
    --canvas-bg:#101226;--canvas-border:#2a2d55;
    --slider-bg:#1e2142;--brush-indicator-bg1:#1b1d3b;--brush-indicator-bg2:#353a62;
    --pill-bg:#0d1024;--pill-border:#2a2d55;--pill-color:#cbd1ff;
    --kbd-bg:#161936;--kbd-border:#2c2f69;--kbd-color:#cbd1ff;
    --phase-handle-bg1:#1a1d33;--phase-handle-bg2:#121428;--phase-handle-color:#b8c3ff;
    --toast-bg:#101225;--toast-border:#293055;
    --modal-bg:rgba(10,12,25,.78);--modal-panel-bg1:#121528;--modal-panel-bg2:#0d0f1e;--modal-panel-border:#262c45;
    --help-card-bg:#161a33;--help-card-border:#262c45;
    --tooltip-bg:#1a1d33;--tooltip-border:#3a4060;
    --sparkle-color:rgba(255,255,255,.35);
    --shadow-light:rgba(255,255,255,.04);--shadow-dark:rgba(0,0,0,.35);
  }
  [data-theme="light"]{
    --bg1:#f5f6ff;--bg2:#e8eaff;--fg:#1e2044;--muted:#6b6f8a;--accent:#5a69ff;--accent2:#3a7fff;
    --bg-gradient1:#d5d7f0;--bg-gradient2:#c2c8e8;
    --controls-bg1:#e5e7ff;--controls-bg2:#f0f2ff;
    --card-bg1:#f8faff;--card-bg2:#f0f2ff;--card-border:#d0d4e8;
    --input-bg:#ffffff;--input-border:#c0c6dd;
    --control-bg:#f4f6ff;--control-border:#d4d8ec;
    --toolbar-bg1:#f0f2ff;--toolbar-bg2:#f8faff;--toolbar-border:#d8dce8;
    --canvas-bg:#ffffff;--canvas-border:#c0c6dd;
    --slider-bg:#d8dce8;--brush-indicator-bg1:#e0e4f0;--brush-indicator-bg2:#c8cedc;
    --pill-bg:#f0f2ff;--pill-border:#c0c6dd;--pill-color:#4a5078;
    --kbd-bg:#e8eaff;--kbd-border:#c0c6dd;--kbd-color:#4a5078;
    --phase-handle-bg1:#e0e4f0;--phase-handle-bg2:#f0f2ff;--phase-handle-color:#5a69ff;
    --toast-bg:#f8faff;--toast-border:#c0c6dd;
    --modal-bg:rgba(240,242,255,.85);--modal-panel-bg1:#f8faff;--modal-panel-bg2:#f0f2ff;--modal-panel-border:#c0c6dd;
    --help-card-bg:#f4f6ff;--help-card-border:#d0d4e8;
    --tooltip-bg:#ffffff;--tooltip-border:#b0b6cd;
    --sparkle-color:rgba(0,0,0,.15);
    --shadow-light:rgba(255,255,255,.8);--shadow-dark:rgba(0,0,0,.15);
  }

  html,body{height:100%}
  *{
    transition: all 1s linear;
  }
  
  .theme-transitioning {
    overflow: hidden;
    position: relative;
  }
  
  .theme-transitioning::before {
    content: '';
    position: fixed;
    top: var(--theme-ripple-y, 50%);
    left: var(--theme-ripple-x, 50%);
    width: 0;
    height: 0;
    border-radius: 50%;
    background: var(--bg1);
    transform: translate(-50%, -50%);
    z-index: 9999;
    pointer-events: none;
    animation: themeRipple 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
  }
  
  @keyframes themeRipple {
    0% { 
      width: 0; 
      height: 0; 
      opacity: 0; 
    }
    10% { 
      opacity: 0.8; 
    }
    100% { 
      width: 250vw; 
      height: 250vh; 
      opacity: 0; 
    }
  }
  
  @keyframes themeParticles {
    0% { 
      transform: translateY(0) rotate(0deg) scale(0);
      opacity: 0;
    }
    100% { 
      transform: translateY(-100px) rotate(360deg) scale(0);
      opacity: 0;
    }
  }
  
  body{
    margin:0;color:var(--fg);
    background:
      radial-gradient(1200px 600px at 10% -10%, var(--bg-gradient1) 0%, transparent 60%),
      radial-gradient(900px 600px at 110% 10%, var(--bg-gradient2) 0%, transparent 60%),
      linear-gradient(180deg, var(--bg1), var(--bg2));
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Inter, Roboto, "Helvetica Neue", Arial;
    overflow-x:hidden;
  }
  .sparkle{position:fixed;inset:0;pointer-events:none;opacity:.45;z-index:0;
    background:
      radial-gradient(2px 2px at 20% 30%, var(--sparkle-color), transparent 60%),
      radial-gradient(1.5px 1.5px at 80% 20%, var(--sparkle-color), transparent 60%),
      radial-gradient(1.5px 1.5px at 60% 75%, var(--sparkle-color), transparent 60%),
      radial-gradient(2px 2px at 35% 60%, var(--sparkle-color), transparent 60%);
    animation: twinkle 6s ease-in-out infinite alternate;
  }
  @keyframes twinkle{from{filter:brightness(.9) blur(0px)}to{filter:brightness(1.3) blur(.3px)}}
  header{position:relative;z-index:2;padding:28px 24px 10px;text-align:center}
  h1{margin:0 0 8px;font-weight:800;letter-spacing:.3px;font-size:clamp(20px,4vw,34px);
    background:linear-gradient(90deg,var(--fg),var(--accent2));-webkit-background-clip:text;background-clip:text;color:transparent;
    animation:shine 8s linear infinite;background-size:200% 100%}
  @keyframes shine{to{background-position:200% 0}}
  .wrap{position:relative;z-index:2;max-width:1400px;margin:22px auto;padding:0 18px 40px}
  .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:space-between;padding:16px;border-radius:14px;
    background:linear-gradient(180deg,var(--controls-bg1),var(--controls-bg2));box-shadow:0 10px 30px var(--shadow-dark), inset 0 1px 0 var(--shadow-light)}
  .controls-left{display:flex;gap:12px;flex-wrap:wrap}
  .controls-right{display:flex;gap:12px;margin-left:auto;align-items:center}
  .control{display:flex;align-items:center;gap:8px;padding:8px 10px;background:var(--control-bg);border:1px solid var(--control-border);border-radius:12px}
  .control label{font-size:12px;color:var(--muted)}
  .control input{width:80px;padding:8px 10px;border-radius:10px;border:1px solid var(--input-border);background:var(--input-bg);color:var(--fg);outline:none;appearance:textfield}
  .control input::-webkit-outer-spin-button,
  .control input::-webkit-inner-spin-button{margin:0;-webkit-appearance:none}
  .control input.input-error{border-color:#ff6b6b;animation:shake .3s ease}
  .btn{border:none;color:#0b0d18;background:linear-gradient(90deg,var(--accent),var(--accent2));padding:10px 14px;border-radius:12px;font-weight:700;letter-spacing:.4px;
    box-shadow:0 8px 18px rgba(124,156,255,.35);cursor:pointer;transition:transform .12s ease, filter .12s ease}
  .btn:hover{transform:translateY(-1px) scale(1.02);filter:brightness(1.07)}
  .btn--icon{display:flex;align-items:center;gap:8px}
  .btn--icon svg{width:16px;height:16px}
  .btn--ghost{padding:10px 14px;border-radius:12px;background:var(--control-bg);border:1px solid var(--control-border);color:var(--fg);font-weight:600;letter-spacing:.4px;transition:transform .12s ease, filter .12s ease}
  .btn--ghost:hover{transform:translateY(-1px);filter:brightness(1.1)}
  .toggleBtn{display:flex;align-items:center;gap:8px;border:none;padding:10px 16px;border-radius:12px;background:linear-gradient(90deg,var(--control-bg),var(--card-bg2));
    color:var(--fg);font-weight:600;letter-spacing:.4px;cursor:pointer;box-shadow:0 6px 16px var(--shadow-dark);transition:transform .15s ease,box-shadow .15s ease}
  .toggleBtn:hover{transform:translateY(-1px);box-shadow:0 10px 24px var(--shadow-dark)}
  .toggleBtn[data-mode="draw"]{background:linear-gradient(90deg,var(--accent),var(--accent2));color:var(--bg1);box-shadow:0 10px 24px var(--shadow-dark)}
  .toggleBtn span{font-size:12px;text-transform:uppercase;letter-spacing:.6px}
  .toggleBtn strong{font-size:12px;text-transform:uppercase;letter-spacing:.6px}
  .toolbar{display:flex;align-items:center;justify-content:space-between;margin-top:12px;padding:12px 16px;border-radius:12px;background:linear-gradient(180deg,var(--toolbar-bg1),var(--toolbar-bg2));border:1px solid var(--toolbar-border);box-shadow:0 10px 22px var(--shadow-dark)}
  .toolbar-left{display:flex;align-items:center;gap:12px}
  .toolbar-right{display:flex;align-items:center;gap:12px;font-size:12px;color:var(--muted);margin-left:auto}
  .brushPower{display:flex;align-items:center;gap:12px;font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:.4px;position:relative}
  .brushPower input{width:160px;appearance:none;height:4px;border-radius:999px;background:var(--slider-bg);outline:none;margin:0;position:relative}
  .brushPower input::-webkit-slider-thumb{appearance:none;width:14px;height:14px;border-radius:50%;background:var(--accent2);box-shadow:0 0 6px rgba(142,240,255,.6);cursor:pointer;transition:all 0.2s ease}
  .brushPower input::-moz-range-thumb{width:14px;height:14px;border-radius:50%;background:var(--accent2);border:none;box-shadow:0 0 6px rgba(142,240,255,.6);cursor:pointer;transition:all 0.2s ease}
  .brushPower input::-webkit-slider-thumb:hover{transform:scale(1.3);box-shadow:0 0 12px rgba(142,240,255,.8)}
  .brushPower input::-moz-range-thumb:hover{transform:scale(1.3);box-shadow:0 0 12px rgba(142,240,255,.8)}
  
  .slider-tooltip{
    position:absolute;
    top:-45px;
    background:var(--tooltip-bg);
    border:1px solid var(--tooltip-border);
    color:var(--fg);
    padding:6px 10px;
    border-radius:8px;
    font-size:11px;
    font-weight:600;
    pointer-events:none;
    opacity:0;
    transform:translateX(-50%) translateY(10px) scale(0.8);
    transition:all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    z-index:100;
    box-shadow:0 4px 12px var(--shadow-dark);
    white-space:nowrap;
  }
  
  .slider-tooltip::after{
    content:'';
    position:absolute;
    top:100%;
    left:50%;
    transform:translateX(-50%);
    width:0;
    height:0;
    border-left:6px solid transparent;
    border-right:6px solid transparent;
    border-top:6px solid var(--tooltip-border);
  }
  
  .slider-tooltip.show{
    opacity:1;
    transform:translateX(-50%) translateY(0) scale(1);
  }
  .brushPower-indicator{display:inline-flex;align-items:center;justify-content:center;min-width:32px;padding:6px 8px;border-radius:8px;background:linear-gradient(135deg, var(--brush-indicator-bg1), var(--brush-indicator-bg2));color:var(--fg);font-weight:700;font-variant-numeric:tabular-nums;font-size:11px;transition:background .3s ease,color .3s ease;cursor:pointer;box-shadow:inset 0 0 0 1px var(--shadow-light)}
  .brushPower-indicator[data-intensity]:not([data-intensity="0"]){background:linear-gradient(135deg, var(--accent), var(--accent2));color:var(--bg1)}
  .brushPower-indicator[data-intensity="0"]{background:linear-gradient(135deg, var(--brush-indicator-bg1), var(--brush-indicator-bg2));color:var(--muted)}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  .note{font-size:11px;color:var(--muted)}
  .note--inline{text-align:left;margin-top:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:18px;margin-top:18px}
  .card{position:relative;background:linear-gradient(180deg,var(--card-bg1),var(--card-bg2));border:1px solid var(--card-border);border-radius:16px;overflow:hidden;
    box-shadow:0 10px 30px var(--shadow-dark);transition:transform .2s ease, box-shadow .2s ease}
  .card:hover{transform:translateY(-2px);box-shadow:0 16px 40px var(--shadow-dark)}
  .card-header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid var(--card-border);background:linear-gradient(180deg, var(--shadow-light), transparent)}
  .card-header h2{margin:0;font-size:14px;letter-spacing:.6px;text-transform:uppercase;color:var(--accent)}
  .card h2{margin:0;padding:12px 14px;font-size:14px;letter-spacing:.6px;text-transform:uppercase;color:var(--accent);border-bottom:1px solid var(--card-border);
    background:linear-gradient(180deg, var(--shadow-light), transparent)}
  .canvasWrap{padding:12px;min-height:420px}
  .canvasRow{display:flex;gap:12px;align-items:stretch}
  .stack{position:relative;width:100%;aspect-ratio:1;min-height:360px}
  canvas.base{position:absolute;inset:0;width:100%;height:100%;background:var(--canvas-bg);border-radius:12px;border:1px solid var(--canvas-border);cursor:crosshair;image-rendering:pixelated;
    box-shadow:inset 0 0 0 1px var(--shadow-light), 0 12px 24px var(--shadow-dark);transition:transform .15s ease, filter .15s ease}
  canvas.base:active{transform:scale(0.999);filter:brightness(1.06)}
  canvas.overlay{position:absolute;inset:0;pointer-events:none;width:100%;height:100%}
  .legend{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:var(--muted);padding:8px 12px 14px}
  .colorBar{width:18px;border-radius:12px;position:relative;display:flex;flex-direction:column;justify-content:space-between;align-items:center;padding:8px 2px;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.08), 0 6px 14px rgba(0,0,0,.3);font-size:10px;color:#cbd1ff;text-transform:uppercase;letter-spacing:.4px}
  .colorBar--intensity{background:linear-gradient(to top,#000000,#ffffff)}
  .colorBar--magnitude{background:linear-gradient(to top,#05060f,#ffffff)}
  .colorBar--phase{background:linear-gradient(to top,#0a0a13,#f0f2ff)}
  .colorBar__label{writing-mode:vertical-rl;transform:rotate(180deg);font-weight:600}
  .colorBar__label--top{align-self:flex-start;margin-top:-2px;color:#000}
  .colorBar__label--bottom{align-self:flex-end;margin-bottom:-2px}
  .pill{display:inline-flex;align-items:center;gap:8px;background:var(--pill-bg);border:1px dashed var(--pill-border);color:var(--pill-color);border-radius:999px;padding:6px 10px;font-size:12px}
  .dot{width:8px;height:8px;border-radius:50%;background:#3ee98a;box-shadow:0 0 10px #3ee98a}
  .kbd{padding:.5px 6px;border-radius:6px;background:var(--kbd-bg);border:1px solid var(--kbd-border);color:var(--kbd-color);font-size:12px}
  .tripleGroup{display:flex;align-items:stretch;gap:10px;position:relative}
  .tripleGroup{--phase-width:33%;}
  .tripleGroup.phase-hidden{--phase-width:0%}
  .tripleGroup .triple-card{flex:1 1 0;display:flex;flex-direction:column;transition:flex-basis .5s cubic-bezier(.4,.12,.2,1), max-width .5s cubic-bezier(.4,.12,.2,1), opacity .35s ease, transform .5s cubic-bezier(.4,.12,.2,1);will-change:flex-basis,max-width,transform,opacity}
  .tripleGroup .triple-card.phase-card{flex-basis:var(--phase-width);max-width:var(--phase-width)}
  .tripleGroup.phase-hidden .triple-card.phase-card{opacity:0;transform:translateX(-14px);pointer-events:none}
  .phaseHandle{position:relative;align-self:center;width:26px;min-width:26px;height:120px;border:none;background:linear-gradient(180deg,var(--phase-handle-bg1),var(--phase-handle-bg2));color:var(--phase-handle-color);display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:14px;font-weight:600;border-radius:14px;transition:background .3s ease, color .3s ease, box-shadow .3s ease, transform .4s cubic-bezier(.4,.12,.2,1)}
  .phaseHandle::before{content:"";position:absolute;inset:0;border-radius:inherit;box-shadow:0 4px 12px var(--shadow-dark),0 0 0 1px var(--shadow-light)}
  .phaseHandle svg{width:14px;height:14px;transition:transform .35s ease}
  .phaseHandle[data-open="false"] svg{transform:rotate(0deg)}
  .phaseHandle[data-open="true"] svg{transform:rotate(180deg)}
  .phaseHandle[data-open="false"]{transform:translateX(-2px)}
  .phaseHandle[data-open="true"]{transform:translateX(0)}
  .phaseHandle:hover{background:linear-gradient(180deg,var(--phase-handle-bg1),var(--phase-handle-bg2));color:var(--fg);filter:brightness(1.1)}
  .phaseHandle:active{background:linear-gradient(180deg,var(--phase-handle-bg1),var(--phase-handle-bg2));filter:brightness(0.9)}
  .phaseHandle span{display:none}
  .footer-note{margin-top:10px;color:var(--muted);font-size:12px;text-align:center}
  .tipsBar{margin:18px 0 4px;display:flex;gap:10px;overflow-x:auto;padding:6px 4px 2px;scroll-snap-type:x mandatory;-webkit-overflow-scrolling:touch}
  .tipsBar::-webkit-scrollbar{height:6px}
  .tipsBar::-webkit-scrollbar-track{background:var(--shadow-light);border-radius:20px}
  .tipsBar::-webkit-scrollbar-thumb{background:linear-gradient(90deg,var(--card-border),var(--control-border));border-radius:20px}
  .tipChip{flex:0 0 auto;scroll-snap-align:start;display:inline-flex;align-items:center;gap:6px;font-size:11px;font-weight:600;letter-spacing:.4px;padding:8px 12px;border-radius:14px;background:linear-gradient(135deg,var(--card-bg2),var(--card-bg1));border:1px solid var(--card-border);color:var(--fg);position:relative}
  .tipChip::after{content:"";position:absolute;inset:0;border-radius:inherit;box-shadow:0 4px 10px var(--shadow-dark),0 0 0 1px var(--shadow-light);pointer-events:none}
  .tipKey{display:inline-flex;align-items:center;justify-content:center;min-width:18px;height:18px;padding:0 4px;border-radius:6px;background:var(--kbd-bg);border:1px solid var(--kbd-border);font-size:10px;font-weight:700;color:var(--kbd-color);box-shadow:0 1px 2px var(--shadow-dark) inset}
  .tipEm{color:#8ef0ff;font-weight:700}
  .tipDivider{width:2px;background:linear-gradient(180deg,rgba(255,255,255,.06),transparent 60%);align-self:stretch;border-radius:1px;margin:0 2px}
  @media (max-width:700px){.tipsBar{mask-image:linear-gradient(90deg,transparent 0,#000 12px,#000 calc(100% - 24px),transparent 100%);}}
  @keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-4px)}50%{transform:translateX(4px)}75%{transform:translateX(-4px)}}
  @media (max-width:1100px){
    .tripleGroup{flex-direction:column}
    .phaseHandle{flex-direction:row;width:100%;min-height:48px;border-radius:12px}
    .phaseHandle span{writing-mode:horizontal-tb;transform:none}
  }
  .toast{position:fixed;right:16px;bottom:16px;z-index:999;background:var(--toast-bg);border:1px solid var(--toast-border);color:var(--fg);border-radius:12px;padding:10px 14px;
    box-shadow:0 10px 18px var(--shadow-dark);transform:translateY(16px);opacity:0;transition:.25s ease;max-width:320px;font-size:13px}
  .toast.show{transform:translateY(0);opacity:1}
  a{color:var(--accent2)}
  .modalRoot{
    position:fixed;inset:0;display:flex;align-items:flex-start;justify-content:center;
    padding:60px 20px 40px;background:var(--modal-bg);
    backdrop-filter:blur(0px) saturate(100%);z-index:400;opacity:0;pointer-events:none;
    transition:opacity 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
               backdrop-filter 0.8s cubic-bezier(0.23, 1, 0.32, 1);
  }
  .modalRoot[data-open="true"]{
    opacity:1;pointer-events:auto;
    backdrop-filter:blur(12px) saturate(140%);
  }
  .modalPanel{
    width:min(860px,100%);
    background:linear-gradient(180deg,var(--modal-panel-bg1),var(--modal-panel-bg2));
    border:1px solid var(--modal-panel-border);border-radius:20px;
    padding:28px 32px 34px;
    box-shadow:0 20px 50px -10px var(--shadow-dark),0 0 0 1px var(--shadow-light);
    color:var(--fg);position:relative;font-size:15px;line-height:1.55;
    transform:translateY(-40px) scale(0.85) rotateX(20deg);opacity:0;
    transition:transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1), 
               opacity 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94),
               box-shadow 0.8s cubic-bezier(0.23, 1, 0.32, 1);
  }
  .modalRoot[data-open="true"] .modalPanel{
    transform:translateY(0) scale(1) rotateX(0deg);opacity:1;
    box-shadow:0 30px 80px -10px var(--shadow-dark),0 0 0 1px var(--shadow-light);
  }
  .modalPanel::before{content:"";position:absolute;inset:0;border-radius:inherit;padding:1px;background:linear-gradient(140deg,rgba(124,156,255,.35),transparent 40%,rgba(142,240,255,.25));-webkit-mask:linear-gradient(#000,#000) content-box, linear-gradient(#000,#000);mask:linear-gradient(#000,#000) content-box, linear-gradient(#000,#000);-webkit-mask-composite:xor;mask-composite:exclude;opacity:.7}
  .modalHeader{display:flex;align-items:center;gap:14px;margin:0 0 14px}
  .modalHeader h2{flex:1;margin:0;font-size:20px;letter-spacing:.5px;font-weight:700;background:linear-gradient(90deg,var(--fg),var(--accent2));-webkit-background-clip:text;background-clip:text;color:transparent}
  .modalClose{border:none;background:linear-gradient(135deg,var(--phase-handle-bg1),var(--phase-handle-bg2));color:var(--fg);width:42px;height:42px;border-radius:14px;display:inline-flex;align-items:center;justify-content:center;cursor:pointer;font-size:16px;font-weight:600;box-shadow:0 6px 16px var(--shadow-dark);transition:.2s ease;outline:none;position:relative;z-index:10}
  .modalClose:hover{color:var(--fg);filter:brightness(1.1);transform:scale(1.05)}
  .modalClose:active{transform:scale(0.95);filter:brightness(0.9)}
  .modalClose svg{pointer-events:none}
  .modalBody{max-height:calc(70vh - 40px);overflow-y:auto;padding-right:4px}
  .modalBody::-webkit-scrollbar{width:10px}
  .modalBody::-webkit-scrollbar-track{background:var(--shadow-light);border-radius:20px}
  .modalBody::-webkit-scrollbar-thumb{background:linear-gradient(180deg,var(--modal-panel-border),var(--card-border));border-radius:20px}
  .helpGrid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:18px;margin:26px 0 6px}
  .helpCard{background:var(--help-card-bg);border:1px solid var(--help-card-border);border-radius:14px;padding:14px 16px;box-shadow:0 4px 14px var(--shadow-dark);font-size:13px;line-height:1.4;position:relative}
  .helpCard h3{margin:0 0 6px;font-size:12px;letter-spacing:.6px;font-weight:700;text-transform:uppercase;color:var(--accent)}
  .inlineKey{display:inline-block;background:var(--kbd-bg);border:1px solid var(--kbd-border);padding:2px 6px;border-radius:6px;font-size:11px;font-weight:600;color:var(--kbd-color);margin:0 2px}
  .softSep{height:1px;background:linear-gradient(90deg,transparent,var(--shadow-light),transparent);margin:26px 0 20px}
  .miniNote{font-size:12px;color:var(--muted);margin-top:18px}
  .faint{color:var(--muted)}
  .accentWord{color:var(--accent2);font-weight:600}
  .themeToggle{
    position:absolute;right:24px;top:50%;transform:translateY(-50%);
    border:none;
    background:linear-gradient(135deg,rgba(124,156,255,.15),rgba(142,240,255,.1));
    color:var(--muted);width:40px;height:40px;border-radius:12px;
    display:flex;align-items:center;justify-content:center;cursor:pointer;
    font-size:18px;border:1px solid rgba(124,156,255,.2);
    transition:all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    box-shadow:0 4px 12px var(--shadow-dark);
    position:relative;overflow:hidden;
  }
  
  .themeToggle::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: linear-gradient(135deg,rgba(124,156,255,.3),rgba(142,240,255,.25));
    transform: translate(-50%, -50%);
    transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
    z-index: -1;
  }
  
  .themeToggle:hover{
    background:linear-gradient(135deg,rgba(124,156,255,.25),rgba(142,240,255,.2));
    color:var(--fg);
    transform:translateY(-50%) scale(1.08) rotate(5deg);
    box-shadow:0 8px 20px var(--shadow-dark);
  }
  
  .themeToggle:hover::before {
    width: 120%;
    height: 120%;
  }
  
  .themeToggle:active {
    transform:translateY(-50%) scale(1.02) rotate(-2deg);
  }
  
  .theme-icon{
    transition:opacity 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
               transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  .theme-icon-dark{display:none;opacity:0;transform:rotate(-180deg) scale(0.3)}
  .theme-icon-light{display:block;opacity:1;transform:rotate(0deg) scale(1)}
  [data-theme="dark"] .theme-icon-dark{display:block;opacity:1;transform:rotate(0deg) scale(1)}
  [data-theme="dark"] .theme-icon-light{opacity:0;transform:rotate(180deg) scale(0.3)}
  [data-theme="dark"] .theme-icon-light{display:none;opacity:0}
  .themeToggle {
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                color 0.6s ease, 
                background-color 0.6s ease;
  }

  @media (max-width:680px){
    .modalPanel{padding:24px 22px 30px}
    .modalHeader h2{font-size:18px}
  }
</style>
</head>
<body>
<div class="sparkle" aria-hidden="true"></div>
<header>
  <h1>2D discerete Fourier Transformation Visualization</h1>
  <button id="themeToggle" class="themeToggle" type="button" aria-label="Toggle theme" title="Toggle dark/light theme">
    <svg class="theme-icon theme-icon-dark" viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"/></svg>
    <svg class="theme-icon theme-icon-light" viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm0-10c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0-4c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1s-1 .45-1 1v2c0 .55.45 1 1 1zm0 20c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1zM5.99 4.58c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41L5.99 4.58zm12.37 12.37c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0 .39-.39.39-1.03 0-1.41l-1.06-1.06zm1.06-10.96c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06zM7.05 18.36c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06z"/></svg>
  </button>
</header>

<div class="wrap">
  <div class="controls" role="group" aria-label="Canvas and transform controls">
    <div class="controls-left">
      <div class="control"><label for="size">Image Size</label><input id="size" type="number" min="8" step="8" value="128" /></div>
    </div>
    <div class="controls-right">
      <input id="uploadInput" type="file" accept="image/*" hidden />
      <button id="uploadBtn" class="btn btn--icon" type="button" title="Upload image">
        <svg aria-hidden="true" viewBox="0 0 24 24"><path d="M7 17a4 4 0 004 4h5a4 4 0 000-8h-6a3 3 0 110-6h6" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><path d="M12 3v10" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><path d="M9 6l3-3 3 3" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <span>Upload Image</span>
      </button>
      <button id="refreshToggle" class="toggleBtn" type="button" data-mode="draw"><span>Refresh:</span><strong id="refreshModeLabel">On Draw</strong></button>
      <button id="helpBtn" class="btn btn--ghost" type="button">Help</button>
    </div>
  </div>

  <div class="toolbar" aria-label="Brush controls">
    <div class="toolbar-left">
      <label class="brushPower" for="brushPower"><span>Power</span><span class="sr-only">Brush power</span>
        <input id="brushPower" type="range" min="0" max="255" step="1" value="32" />
        <div class="slider-tooltip" id="brushPowerTooltip">0.00</div>
        <span class="brushPower-indicator" id="brushPowerValue">&nbsp;</span>
      </label>
    </div>
    <div class="toolbar-right">
      <span class="brushInfo">Brush: <span id="brushSizeLabel">7</span> px • <span class="kbd">Scroll</span> on canvases to change</span>
    </div>
  </div>

  <div class="tipsBar" aria-label="Quick tips">
    <div class="tipChip"><span class="tipKey">LMB</span> paint <span class="tipEm">add</span></div>
    <div class="tipChip"><span class="tipKey">RMB</span> paint <span class="tipEm">subtract</span></div>
    <div class="tipChip"><span class="tipKey">Scroll</span> resize brush</div>
    <div class="tipChip"><span class="tipKey">Freq</span> edit magnitude</div>
    <div class="tipChip"><span class="tipKey">Phase</span> adjust phase (toggle)</div>
    <div class="tipChip"><span class="tipKey">Upload</span> bring your image</div>
  </div>

  <div class="grid">
    <section class="card" aria-label="Domains">
      <h2 style="display:none">Domains</h2>
      <div class="canvasWrap" style="padding:18px">
  <div class="tripleGroup phase-hidden" id="tripleGroup">
          <div class="card triple-card" aria-label="Image domain">
            <div class="card-header">Image Domain</div>
            <div class="canvasWrap">
              <div class="canvasRow">
                <div class="colorBar colorBar--intensity" aria-hidden="true">
                  <span class="colorBar__label colorBar__label--top">255</span>
                  <span class="colorBar__label colorBar__label--bottom">0</span>
                </div>
                <div class="stack">
                  <canvas id="image" class="base"></canvas>
                  <canvas id="overlayImage" class="overlay"></canvas>
                </div>
              </div>
            </div>
            <div class="legend">
              <span class="pill"><span class="dot"></span> Editable • LMB adds, RMB subtracts</span>
            </div>
          </div>
          <div class="card triple-card" aria-label="Frequency magnitude domain">
            <div class="card-header">Frequency Domain (Magnitude)</div>
            <div class="canvasWrap">
              <div class="canvasRow">
                <div class="colorBar colorBar--magnitude" aria-hidden="true">
                  <span class="colorBar__label colorBar__label--top">Log(255)</span>
                  <span class="colorBar__label colorBar__label--bottom">0</span>
                </div>
                <div class="stack">
                  <canvas id="freq" class="base"></canvas>
                  <canvas id="overlayFreq" class="overlay"></canvas>
                </div>
              </div>
            </div>
            <div class="legend">
              <span class="pill"><span class="dot"></span> Editable • LMB adds, RMB subtracts</span>
            </div>
          </div>
          <div class="card triple-card phase-card" aria-label="Frequency phase domain">
            <div class="card-header">Frequency Domain (Phase)</div>
            <div class="canvasWrap">
              <div class="canvasRow">
                <div class="colorBar colorBar--phase" aria-hidden="true">
                  <span class="colorBar__label colorBar__label--top">2pi</span>
                  <span class="colorBar__label colorBar__label--bottom">0</span>
                </div>
                <div class="stack">
                  <canvas id="phase" class="base"></canvas>
                  <canvas id="overlayPhase" class="overlay"></canvas>
                </div>
              </div>
            </div>
            <div class="legend">
              <span class="pill"><span class="dot"></span> Editable • LMB adds, RMB subtracts</span>
            </div>
          </div>
          <button class="phaseHandle" id="phaseToggle" type="button" title="Show phase" aria-label="Show phase" aria-pressed="false" data-open="false">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M9 5l7 7-7 7" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" /></svg>
            <span>Toggle</span>
          </button>
          <span id="phaseToggleStatus" class="sr-only" aria-live="polite"></span>
        </div>
      </div>
    </section>
  </div>
</div>


<div id="toast" class="toast" role="status" aria-live="polite"></div>
<div id="helpModal" class="modalRoot" role="dialog" aria-modal="true" aria-labelledby="helpTitle" data-open="false">
  <div class="modalPanel" role="document">
    <div class="modalHeader">
      <h2 id="helpTitle">Help</h2>
      <button type="button" id="helpClose" class="modalClose" aria-label="Close help">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>
    <div class="modalBody" id="helpBody">
      <p><strong>What is this?</strong><br/>A small sandbox to explore how an image is built from hidden wave patterns. Left: the picture. Middle: how strong each pattern is (magnitude). Optional panel: how those patterns line up (phase).</p>
      <div class="helpGrid">
        <div class="helpCard"><h3>Basics</h3><p><span class="inlineKey">LMB</span> add / paint<br/><span class="inlineKey">RMB</span> subtract<br/><span class="inlineKey">Scroll</span> brush size<br/><span class="inlineKey">Shift</span> gentler change</p></div>
        <div class="helpCard"><h3>Panels</h3><p>Magnitude = how loud each wave is.<br/>Phase = when each wave starts.<br/>Both rebuild the image together.</p></div>
        <div class="helpCard"><h3>Try This</h3><p>Paint a dot in the image: frequency view lights everywhere.<br/>Erase near the center in magnitude: lose broad structure.</p></div>
        <div class="helpCard"><h3>Phase</h3><p>Changing only phase can shuffle structure while keeping overall energy. Zero magnitude means phase there is irrelevant.</p></div>
      </div>
      <div class="softSep"></div>
      <p><strong>Mental picture:</strong> A choir: magnitude is loudness, phase is timing. Change loudness: different song shape. Change timing: different blend.</p>
      <p class="miniNote">Reset by choosing a new size. Upload converts your image to grayscale. Have fun.</p>
    </div>
  </div>
</div>

<script type="module">
import WebFFT from 'https://cdn.jsdelivr.net/npm/webfft@1.0.3/lib/main.js';
const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
const nextPow2=n=>1<<Math.max(3,Math.ceil(Math.log2(Math.max(8,n|0))));
const isPow2=n=>n>0 && (n & (n-1))===0;
const to255=v=>Math.round(clamp(v,0,225)*255/225);
const LOG_DRAW_FULL=Math.log1p(225);
const LOG_DISPLAY_MAX=LOG_DRAW_FULL;
const TWO_PI=Math.PI*2;
const PHASE_MIN_RAD=0;
const PHASE_MAX_RAD=TWO_PI;
function toast(msg, ms=1500){
  const el=document.getElementById('toast');
  el.textContent=msg; el.classList.add('show');
  clearTimeout(toast._t); toast._t=setTimeout(()=>el.classList.remove('show'),ms);
}

function attachSliderWithWheel(input, onChange){
  const step=Number(input.step)||1;
  const min=input.min!==''?Number(input.min):-Infinity;
  const max=input.max!==''?Number(input.max):Infinity;
  const decimals=input.step&&input.step.includes('.')?input.step.split('.')[1].length:0;
  const formatter=decimals>0?(v)=>v.toFixed(decimals):(v)=>String(Math.round(v));
  input.addEventListener('input', ()=>{
    const value=Number(input.value);
    onChange(value);
  });
  input.addEventListener('wheel', e=>{
    e.preventDefault();
    const delta=e.deltaY<0?step:-step;
    const current=Number(input.value);
    let next=clamp(current+delta,min,max);
    if(decimals>0) next=Number(next.toFixed(decimals));
    input.value=formatter(next);
    onChange(next);
  }, {passive:false});
}

function wrapToPi(angle){
  if(angle > Math.PI) return Math.PI;
  if(angle < -Math.PI) return -Math.PI;
  return angle;
}

function wrapToTwoPi(angle){
  return angle + Math.PI;
}

let webfftInstance=null;
let fftSizeX=0;

function disposeFft(){
  if(webfftInstance){
    try{ webfftInstance.dispose(); }catch(err){ console.warn('FFT dispose failed', err); }
    webfftInstance=null;
  }
  fftSizeX=0;
  forwardInputRows=null;
  freqConjRows=null;
  freqInputRows=null;
}

function ensureFft(){
  if(webfftInstance && fftSizeX===W) return;
  disposeFft();
  webfftInstance=new WebFFT(W, 'indutnyModifiedJavascript', false);
  fftSizeX=W;
}

function fftshift2D(src,W,H){
  const dst=new src.constructor(src.length), hx=W>>1, hy=H>>1;
  for(let y=0;y<H;y++)for(let x=0;x<W;x++){const sx=(x+hx)&(W-1), sy=(y+hy)&(H-1); dst[y*W+x]=src[sy*W+sx]}
  return dst;
}
const ifftshift2D=fftshift2D;

function forwardFFT2D(){
  ensureFft();
  if(!forwardInputRows || forwardInputRows.length!==H || forwardInputRows?.[0]?.length!==2*W){
    forwardInputRows=new Array(H);
    for(let y=0;y<H;y++) forwardInputRows[y]=new Float32Array(2*W);
  }
  for(let y=0;y<H;y++){
    const row=forwardInputRows[y];
    const offset=y*W;
    for(let x=0;x<W;x++){
      const idx=offset+x;
      row[2*x]=img[idx];
      row[2*x+1]=0;
    }
  }
  return webfftInstance.fft2d(forwardInputRows);
}

function inverseFFT2D(freqRows){
  ensureFft();
  if(!freqConjRows || freqConjRows.length!==H || freqConjRows?.[0]?.length!==2*W){
    freqConjRows=new Array(H);
    for(let y=0;y<H;y++) freqConjRows[y]=new Float32Array(2*W);
  }
  for(let y=0;y<H;y++){
    const src=freqRows[y];
    const dst=freqConjRows[y];
    for(let i=0;i<src.length;i+=2){
      dst[i]=src[i];
      dst[i+1]=-src[i+1];
    }
  }
  const forward=webfftInstance.fft2d(freqConjRows);
  const total=totalSize;
  for(let y=0;y<H;y++){
    const row=forward[y];
    for(let i=0;i<row.length;i+=2){
      row[i]=row[i]/total;
      row[i+1]=-row[i+1]/total;
    }
  }
  return forward;
}


const canvImage=document.getElementById('image');
const canvFreq =document.getElementById('freq');
const canvPhase=document.getElementById('phase');
const overImg  =document.getElementById('overlayImage');
const overFft  =document.getElementById('overlayFreq');
const overPhase=document.getElementById('overlayPhase');
const ctxImg=canvImage.getContext('2d',{willReadFrequently:true});
const ctxFft=canvFreq.getContext('2d',{willReadFrequently:true});
const ctxPhase=canvPhase.getContext('2d',{willReadFrequently:true});
const octxImg=overImg.getContext('2d');
const octxFft=overFft.getContext('2d');
const octxPhase=overPhase.getContext('2d');

const refreshToggle=document.getElementById('refreshToggle');
const refreshModeLabel=document.getElementById('refreshModeLabel');
const uploadBtn=document.getElementById('uploadBtn');
const uploadInput=document.getElementById('uploadInput');
const brushPowerInput=document.getElementById('brushPower');
const brushPowerValue=document.getElementById('brushPowerValue');
const brushSizeLabel=document.getElementById('brushSizeLabel');
const sizeInput=document.getElementById('size');
const tripleGroup=document.getElementById('tripleGroup');
const phaseToggle=document.getElementById('phaseToggle');
const introModal=document.getElementById('introModal');
const introDismiss=document.getElementById('introDismiss');
const helpBtn=document.getElementById('helpBtn');
const helpModal=document.getElementById('helpModal');
const helpClose=document.getElementById('helpClose');

let W=nextPow2(parseInt(document.getElementById('size').value,10));
let H=W;
let totalSize=W*H;

let img=new Float64Array(W*H);
let re =new Float64Array(W*H);
let im =new Float64Array(W*H);
let mag=new Float64Array(W*H);
let magLog=new Float64Array(W*H);
let phase=new Float64Array(W*H);
let magShiftedLog=new Float64Array(W*H);
let phaseWrapped=new Float64Array(W*H);
let phaseShiftedDisplay=new Float64Array(W*H);
let freqSyncScheduled=false, freqSyncHandle=null, freqNeedsSync=false;

let brushSize=7;
let brushPower=Number(brushPowerInput.value)||32;
const BRUSH_POWER_DEFAULT=32;
const powerNormDefault=BRUSH_POWER_DEFAULT/255;
const intensityCalib=255;
const frequencyGamma=Math.log(0.1)/Math.log(powerNormDefault);
const frequencyMax=2;
const phaseGamma=Math.log(0.5)/Math.log(powerNormDefault);
const phaseMax=Math.PI/2;

let deltaIntensity=powerNormDefault*intensityCalib;
let deltaFrequency=2*Math.pow(powerNormDefault, frequencyGamma);
let deltaPhase=Math.PI/8;
let drawing=false, drawButton=0;
let activeCanvas=null;
let activeCanvasEl=null;
let lastMouse={x:0,y:0};
let hoverState={canvas:null,x:0,y:0,domain:null};
let refreshMode='draw';
let imgSyncScheduled=false, imgSyncHandle=null, imgNeedsSync=false;
let forwardInputRows=null;
let freqConjRows=null;
let freqInputRows=null;

let currentTheme = 'light';
let hasSeenHelp = false;
let isInitializing = true;

const STORAGE_KEY = 'fourier-vis-settings';
let phaseVisible=false;
function updatePhaseVisibility(){
  if(phaseVisible) tripleGroup.classList.remove('phase-hidden');
  else tripleGroup.classList.add('phase-hidden');
  phaseToggle.setAttribute('data-open', String(phaseVisible));
  phaseToggle.setAttribute('aria-pressed', String(phaseVisible));
  const label=phaseVisible?'Hide phase':'Show phase';
  phaseToggle.setAttribute('title', label);
  phaseToggle.setAttribute('aria-label', label);
  const live=document.getElementById('phaseToggleStatus');
  if(live) live.textContent='Phase panel '+(phaseVisible?'visible':'hidden');
  const resizeAll=()=>{
    sizeOverlayFor(canvImage, overImg);
    sizeOverlayFor(canvFreq, overFft);
    sizeOverlayFor(canvPhase, overPhase);
    if(hoverState.canvas) refreshOverlayPreview();
  };
  resizeAll();
  const onEnd=(e)=>{
    if(e.target.closest && !e.target.closest('#tripleGroup')) return;
    if(e.propertyName==='flex-basis' || e.propertyName==='max-width'){
      resizeAll();
      tripleGroup.removeEventListener('transitionend', onEnd, true);
    }
  };
  tripleGroup.addEventListener('transitionend', onEnd, true);
  if(!phaseVisible){
    octxPhase.clearRect(0,0,overPhase.width,overPhase.height);
  }
  saveSettings();
}
if(phaseToggle){
  phaseToggle.addEventListener('click', ()=>{ phaseVisible=!phaseVisible; updatePhaseVisibility(); });
  updatePhaseVisibility();
}


const DEFAULT_SETTINGS = {
  brushSize: 7,
  brushPower: 32,
  refreshMode: 'draw',
  phaseVisible: false,
  canvasSize: 128,
  theme: 'light',
  hasSeenHelp: false
};

function saveSettings() {
  // Don't save during initialization to avoid overwriting loaded settings
  if (isInitializing) return;
  
  const settings = {
    brushSize,
    brushPower,
    refreshMode,
    phaseVisible,
    canvasSize: W,
    theme: currentTheme,
    hasSeenHelp
  };
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
    console.log('Saved settings to localStorage:', settings, isInitializing);
  } catch (e) {
    console.warn('Could not save settings to localStorage:', e);
  }
}

function loadSettings() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      const settings = JSON.parse(saved);
      isInitializing = false;
      console.log('Loaded settings from localStorage:', settings);
      return { ...DEFAULT_SETTINGS, ...settings };
    }
  } catch (e) {
    console.warn('Could not load settings from localStorage:', e);
  }
  isInitializing = false;
  return DEFAULT_SETTINGS;
}

function setTheme(theme) {
  currentTheme = theme;
  document.documentElement.setAttribute('data-theme', theme);
  const themeToggle = document.getElementById('themeToggle');
  if (themeToggle) {
    themeToggle.setAttribute('aria-label', `Switch to ${theme === 'dark' ? 'light' : 'dark'} theme`);
    themeToggle.setAttribute('title', `Switch to ${theme === 'dark' ? 'light' : 'dark'} theme`);
  }
  saveSettings();
}

function toggleTheme(event) {
  // Get click position for directional ripple
  const button = event ? event.currentTarget : document.querySelector('.themeToggle');
  const rect = button ? button.getBoundingClientRect() : { left: window.innerWidth / 2, top: window.innerHeight / 2 };
  
  // Calculate ripple origin
  const rippleX = rect.left + rect.width / 2;
  const rippleY = rect.top + rect.height / 2;
  
  // Set CSS custom properties for ripple position
  document.documentElement.style.setProperty('--theme-ripple-x', rippleX + 'px');
  document.documentElement.style.setProperty('--theme-ripple-y', rippleY + 'px');
  
  // Add transitioning class
  document.body.classList.add('theme-transitioning');
  
  // Start theme change after a brief delay for ripple to begin
  setTimeout(() => {
    setTheme(currentTheme === 'dark' ? 'light' : 'dark');
  }, 100);
  
  // Remove transitioning class after animation completes
  setTimeout(() => {
    document.body.classList.remove('theme-transitioning');
  }, 2200);
}

function showWelcomeHelpIfFirstTime() {
  const shouldShowHelp = !hasSeenHelp; // Capture the state immediately
  if (shouldShowHelp) {
    setTimeout(() => {
      // Double-check the value hasn't changed
      if (!hasSeenHelp) {
        openHelp();
      }
    }, 800);
  }
}

function updateBrushPower(value){
  brushPower=clamp(value,0,255);
  brushPowerInput.value=String(Math.round(brushPower));
  const powerNorm=brushPower/255;
  
  // Display the normalized power value (0.0 to 1.0)
  brushPowerValue.textContent = powerNorm.toFixed(2);
  
  // Theme-aware brush power indicator styling with gradient intensity
  const intensity = Math.round(powerNorm * 100);
  brushPowerValue.style.removeProperty('background');
  brushPowerValue.style.removeProperty('color');
  brushPowerValue.setAttribute('data-intensity', intensity);
  
  // Add dynamic color gradient based on power level
  if (powerNorm > 0) {
    const hue = 180 + (powerNorm * 60); // From cyan (180) to yellow-green (240)
    const saturation = 70 + (powerNorm * 30); // 70% to 100% saturation
    const lightness = 50 + (powerNorm * 20); // 50% to 70% lightness
    brushPowerValue.style.background = `linear-gradient(135deg, 
      hsl(${hue}, ${saturation}%, ${lightness}%), 
      hsl(${hue + 20}, ${saturation + 10}%, ${lightness - 10}%))`;
    brushPowerValue.style.color = powerNorm > 0.5 ? '#000' : '#fff';
  }
  
  deltaIntensity=powerNorm*intensityCalib;
  deltaFrequency=Math.min(Math.pow(powerNorm, frequencyGamma)*frequencyMax, frequencyMax);
  deltaPhase=Math.min(Math.pow(powerNorm, phaseGamma)*phaseMax, phaseMax);
  const tooltip=`Power: ${powerNorm.toFixed(2)} | dI=${deltaIntensity.toFixed(1)}, dF=${deltaFrequency.toFixed(2)}, dPhase=${deltaPhase.toFixed(2)} rad`;
  brushPowerValue.setAttribute('title',tooltip);
  brushPowerValue.setAttribute('aria-label', tooltip);
  saveSettings();
}

const brushPowerTooltip = document.getElementById('brushPowerTooltip');

function updateSliderTooltip(value, inputElement, tooltip) {
  const normalizedValue = value / 255;
  tooltip.textContent = normalizedValue.toFixed(2);
  
  // Calculate tooltip position based on slider value
  const percent = (value - inputElement.min) / (inputElement.max - inputElement.min);
  const sliderWidth = inputElement.offsetWidth;
  const thumbWidth = 14; // Width of the slider thumb
  const offset = percent * (sliderWidth - thumbWidth) + (thumbWidth / 2);
  
  tooltip.style.left = offset + 'px';
}

attachSliderWithWheel(brushPowerInput, updateBrushPower);
updateBrushPower(brushPower);

// Add input event for real-time tooltip updates
brushPowerInput.addEventListener('input', (e) => {
  const value = Number(e.target.value);
  updateBrushPower(value);
  updateSliderTooltip(value, brushPowerInput, brushPowerTooltip);
});

// Show tooltip on mouse enter/focus
brushPowerInput.addEventListener('mouseenter', () => {
  updateSliderTooltip(Number(brushPowerInput.value), brushPowerInput, brushPowerTooltip);
  brushPowerTooltip.classList.add('show');
});

brushPowerInput.addEventListener('focus', () => {
  updateSliderTooltip(Number(brushPowerInput.value), brushPowerInput, brushPowerTooltip);
  brushPowerTooltip.classList.add('show');
});

// Hide tooltip on mouse leave/blur
brushPowerInput.addEventListener('mouseleave', () => {
  brushPowerTooltip.classList.remove('show');
});

brushPowerInput.addEventListener('blur', () => {
  brushPowerTooltip.classList.remove('show');
});

// Keep tooltip visible while dragging
brushPowerInput.addEventListener('mousedown', () => {
  brushPowerTooltip.classList.add('show');
});

brushPowerValue.addEventListener('wheel', e=>{
  e.preventDefault();
  const delta=e.deltaY<0?5:-5;
  const next=clamp(brushPower+delta,0,255);
  brushPowerInput.value=String(next);
  updateBrushPower(next);
  updateSliderTooltip(next, brushPowerInput, brushPowerTooltip);
});

function loadImageFile(file){
  const url=URL.createObjectURL(file);
  const image=new Image();
  image.crossOrigin='anonymous';
  image.onload=()=>{
    const offscreen=document.createElement('canvas');
    offscreen.width=W;
    offscreen.height=H;
    const offCtx=offscreen.getContext('2d');
    if(!offCtx){
      toast('Unable to process image.', 2000);
      URL.revokeObjectURL(url);
      uploadInput.value='';
      return;
    }
    offCtx.imageSmoothingEnabled=true;
    offCtx.drawImage(image,0,0,W,H);
    const data=offCtx.getImageData(0,0,W,H).data;
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const idx=y*W+x;
        const base=idx*4;
        const r=data[base];
        const g=data[base+1];
        const b=data[base+2];
        const grayscale=0.2126*r+0.7152*g+0.0722*b;
        img[idx]=grayscale*225/255;
      }
    }
    renderImage();
    forwardFromImage();
    toast('Image uploaded and converted to grayscale.', 1800);
    URL.revokeObjectURL(url);
    uploadInput.value='';
  };
  image.onerror=()=>{
    toast('Could not load image.', 2000);
    URL.revokeObjectURL(url);
    uploadInput.value='';
  };
  image.src=url;
}

uploadBtn.addEventListener('click', ()=>uploadInput.click());
uploadInput.addEventListener('change', e=>{
  const file=e.target.files && e.target.files[0];
  if(!file) return;
  loadImageFile(file);
});


function setRefreshMode(mode){
  refreshMode=mode;
  refreshToggle.dataset.mode=mode;
  refreshToggle.setAttribute('aria-pressed', mode==='draw');
  refreshModeLabel.textContent=mode==='draw'?'On Draw':'On Mouse Lift';
  if(mode==='draw'){
    if(imgNeedsSync) scheduleImageSync();
    if(freqNeedsSync) scheduleFrequencySync();
  }else{
    if(imgSyncHandle!==null){
      cancelAnimationFrame(imgSyncHandle);
      imgSyncHandle=null;
      imgSyncScheduled=false;
    }
    if(freqSyncHandle!==null){
      cancelAnimationFrame(freqSyncHandle);
      freqSyncHandle=null;
      freqSyncScheduled=false;
    }
    if(imgNeedsSync) flushImageSync();
    if(freqNeedsSync) flushFrequencySync();
  }
  saveSettings();
}

refreshToggle.addEventListener('click', ()=>{
  setRefreshMode(refreshMode==='draw'?'lift':'draw');
});

setRefreshMode(refreshMode);

function setCanvasSize(){
  canvImage.width=W; canvImage.height=H;
  canvFreq.width=W;  canvFreq.height=H;
  canvPhase.width=W; canvPhase.height=H;
  sizeOverlayFor(canvImage, overImg);
  sizeOverlayFor(canvFreq,  overFft);
  sizeOverlayFor(canvPhase, overPhase);
}
function sizeOverlayFor(base, overlay){
  const dpr=window.devicePixelRatio||1;
  const r=base.getBoundingClientRect();
  overlay.style.width=r.width+'px';
  overlay.style.height=r.height+'px';
  overlay.width=Math.max(1,Math.round(r.width*dpr));
  overlay.height=Math.max(1,Math.round(r.height*dpr));
  const ctx=overlay.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.imageSmoothingEnabled=false;
}


function clearToBlack(){ img.fill(0); }


function renderImage(){
  const id=ctxImg.createImageData(W,H);
  let p=0;
  for(let i=0;i<img.length;i++){
    const v=to255(img[i]);
    id.data[p++]=v; id.data[p++]=v; id.data[p++]=v; id.data[p++]=255;
  }
  ctxImg.putImageData(id,0,0);
}
function renderFreq(){
  const id=ctxFft.createImageData(W,H);
  const inv=LOG_DISPLAY_MAX>0?1/LOG_DISPLAY_MAX:0;
  let p=0;
  for(let i=0;i<magShiftedLog.length;i++){
    const norm=clamp(magShiftedLog[i]*inv,0,1);
    const v=to255(norm*225);
    id.data[p++]=v; id.data[p++]=v; id.data[p++]=v; id.data[p++]=255;
  }
  ctxFft.putImageData(id,0,0);
}

function renderPhase(){
  const id=ctxPhase.createImageData(W,H);
  const range=PHASE_MAX_RAD-PHASE_MIN_RAD || 1;
  // Need unshifted magnitude access aligned with phaseShiftedDisplay pixels: we use magLog (unshifted) so map indices via inverse shift logic.
  const hx=W>>1, hy=H>>1;
  let p=0;
  for(let sy=0; sy<H; sy++){
    for(let sx=0; sx<W; sx++){
      const ux=(sx+hx)&(W-1);
      const uy=(sy+hy)&(H-1);
      const baseIdx=uy*W+ux;
      const magVal=mag[baseIdx];
      let val=phaseShiftedDisplay[sy*W+sx];
      if(magVal===0) val=0; // mask undefined phase where magnitude is zero
      val=clamp(val, PHASE_MIN_RAD, PHASE_MAX_RAD);
      const norm=(val-PHASE_MIN_RAD)/range;
      const g=Math.round(norm*255);
      id.data[p++]=g; id.data[p++]=g; id.data[p++]=g; id.data[p++]=255;
    }
  }
  ctxPhase.putImageData(id,0,0);
}


function forwardFromImage(){
  imgNeedsSync=false;
  const freqRows=forwardFFT2D();
  const total=totalSize;
  for(let y=0;y<H;y++){
    const row=freqRows[y];
    for(let x=0;x<W;x++){
      const idx=y*W+x;
      const r=row[2*x];
      const ii=row[2*x+1];
      re[idx]=r;
      im[idx]=ii;
      const magnitude=Math.hypot(r,ii);
      mag[idx]=magnitude;
      const logVal=Math.min(LOG_DISPLAY_MAX, Math.log1p(magnitude/total));
      magLog[idx]=logVal;
  const phaseVal=Math.atan2(ii,r); // -π..π
  phase[idx]=phaseVal; // store canonical principal value
  phaseWrapped[idx]=wrapToTwoPi(phaseVal); // 0..2π for display
    }
  }
  magShiftedLog.set(fftshift2D(magLog,W,H));
  renderFreq();
  phaseShiftedDisplay.set(fftshift2D(phaseWrapped,W,H));
  renderPhase();
}
function inverseFromFrequencyEdit(){
  freqNeedsSync=false;
  if(!freqInputRows || freqInputRows.length!==H || freqInputRows?.[0]?.length!==2*W){
    freqInputRows=new Array(H);
    for(let y=0;y<H;y++) freqInputRows[y]=new Float32Array(2*W);
  }
  const freqRows=freqInputRows;
  for(let y=0;y<H;y++){
    const row=freqRows[y];
    for(let x=0;x<W;x++){
      const idx=y*W+x;
      const amp=mag[idx];
      const ph=phase[idx];
      const real=amp*Math.cos(ph);
      const imag=amp*Math.sin(ph);
      row[2*x]=real;
      row[2*x+1]=imag;
      re[idx]=real;
      im[idx]=imag;
    }
  }
  const spatialRows=inverseFFT2D(freqRows);
  for(let y=0;y<H;y++){
    const row=spatialRows[y];
    for(let x=0;x<W;x++){
      const idx=y*W+x;
      img[idx]=clamp(row[2*x],0,225);
    }
  }
  renderImage();
  renderPhase();
}


function addCircleToArray(arr,cx,cy,r,delta,min,max){
  const R=Math.max(1,r|0), R2=R*R/2;
  const xmin=clamp((cx|0)-R,0,W-1), xmax=clamp((cx|0)+R,0,W-1);
  const ymin=clamp((cy|0)-R,0,H-1), ymax=clamp((cy|0)+R,0,H-1);
  for(let y=ymin;y<=ymax;y++){
    const dy=y-cy;
    for(let x=xmin;x<=xmax;x++){
      const dx=x-cx;
      if(dx*dx+dy*dy< R2){
        const idx=y*W+x;
        arr[idx]=clamp(arr[idx]+delta,min,max);
      }
    }
  }
}
function mirrorIndexShifted(x,y){
  return {x:(W-x-1)&(W-1), y:(H-y-1)&(H-1)};
}

function shiftedToUnshiftedIndex(x,y){
  const hx=W>>1, hy=H>>1;
  const ux=(x+hx)&(W-1);
  const uy=(y+hy)&(H-1);
  return uy*W+ux;
}

function adjustFrequencyShiftedLogValue(sx,sy,deltaLog){
  const idxShift=sy*W+sx;
  const current=magShiftedLog[idxShift];
  const next=clamp(current+deltaLog,0,LOG_DISPLAY_MAX);
  magShiftedLog[idxShift]=next;
  const idx=shiftedToUnshiftedIndex(sx,sy);
  magLog[idx]=next;
  mag[idx]=Math.max(0,Math.expm1(next)*totalSize);
  const mirror=mirrorIndexShifted(sx,sy);
  if(mirror.x===sx && mirror.y===sy) return;
  const mirrorIdxShift=mirror.y*W+mirror.x;
  magShiftedLog[mirrorIdxShift]=next;
  const idxMirror=shiftedToUnshiftedIndex(mirror.x,mirror.y);
  magLog[idxMirror]=next;
  mag[idxMirror]=Math.max(0,Math.expm1(next)*totalSize);
}

function brushFrequencyCircle(cx,cy,radius,deltaLog){
  const R=Math.max(1,radius|0), R2=R*R/2;
  const xmin=clamp((cx|0)-R,0,W-1), xmax=clamp((cx|0)+R,0,W-1);
  const ymin=clamp((cy|0)-R,0,H-1), ymax=clamp((cy|0)+R,0,H-1);
  for(let y=ymin;y<=ymax;y++){
    const dy=y-cy;
    for(let x=xmin;x<=xmax;x++){
      const dx=x-cx;
      if(dx*dx+dy*dy< R2){
        const mirror=mirrorIndexShifted(x,y);
        adjustFrequencyShiftedLogValue(x,y,deltaLog);
      }
    }
  }
}

function applyFrequencyBrushDelta(cx,cy,radius,deltaLog){
  brushFrequencyCircle(cx,cy,radius,deltaLog);
}

function adjustPhaseShiftedValue(sx,sy,delta){
  const idxShift=sy*W+sx;
  const idx=shiftedToUnshiftedIndex(sx,sy);
  let newPhase=phase[idx]+delta; // operate in -π..π space
  newPhase=wrapToPi(newPhase);   // keep canonical principal value
  phase[idx]=newPhase;
  const wrapped=wrapToTwoPi(newPhase);
  phaseWrapped[idx]=wrapped;
  phaseShiftedDisplay[idxShift]=wrapped;
  const mirror=mirrorIndexShifted(sx,sy);
  if(mirror.x===sx && mirror.y===sy) return;
  const idxMirror=shiftedToUnshiftedIndex(mirror.x,mirror.y);
  let mirrorPhase=-newPhase; // conjugate symmetry
  mirrorPhase=wrapToPi(mirrorPhase);
  phase[idxMirror]=mirrorPhase;
  const mirrorWrapped=wrapToTwoPi(mirrorPhase);
  phaseWrapped[idxMirror]=mirrorWrapped;
  phaseShiftedDisplay[mirror.y*W+mirror.x]=mirrorWrapped;
}

function brushPhaseCircle(cx,cy,radius,delta){
  const R=Math.max(1,radius|0), R2=R*R/2;
  const xmin=clamp((cx|0)-R,0,W-1), xmax=clamp((cx|0)+R,0,W-1);
  const ymin=clamp((cy|0)-R,0,H-1), ymax=clamp((cy|0)+R,0,H-1);
  for(let y=ymin;y<=ymax;y++){
    const dy=y-cy;
    for(let x=xmin;x<=xmax;x++){
      const dx=x-cx;
      if(dx*dx+dy*dy< R2){
        const mirror=mirrorIndexShifted(x,y);
        adjustPhaseShiftedValue(x,y,delta);
      }
    }
  }
}

function applyPhaseBrushDelta(cx,cy,radius,delta){
  brushPhaseCircle(cx,cy,radius,delta);
}

function scheduleImageSync(){
  imgNeedsSync=true;
  if(refreshMode!=='draw') return;
  if(imgSyncScheduled) return;
  imgSyncScheduled=true;
  imgSyncHandle=requestAnimationFrame(()=>{
    imgSyncScheduled=false;
    imgSyncHandle=null;
    if(!imgNeedsSync) return;
    imgNeedsSync=false;
    forwardFromImage();
  });
}

function flushImageSync(){
  if(imgSyncHandle!==null){
    cancelAnimationFrame(imgSyncHandle);
    imgSyncHandle=null;
    imgSyncScheduled=false;
  }
  if(!imgNeedsSync) return;
  imgNeedsSync=false;
  forwardFromImage();
}

function scheduleFrequencySync(){
  freqNeedsSync=true;
  if(refreshMode!=='draw') return;
  if(freqSyncScheduled) return;
  freqSyncScheduled=true;
  freqSyncHandle=requestAnimationFrame(()=>{
    freqSyncScheduled=false;
    freqSyncHandle=null;
    if(!freqNeedsSync) return;
    freqNeedsSync=false;
    inverseFromFrequencyEdit();
  });
}

function flushFrequencySync(){
  if(freqSyncHandle!==null){
    cancelAnimationFrame(freqSyncHandle);
    freqSyncHandle=null;
    freqSyncScheduled=false;
  }
  if(!freqNeedsSync) return;
  freqNeedsSync=false;
  inverseFromFrequencyEdit();
}


function drawOverlay(ctx, base, radius, x, y){
  const r=base.getBoundingClientRect();
  const cellW = r.width / W;
  const cellH = r.height / H;
  const R = Math.max(1, radius|0);
  const xmin=clamp((x|0)-R,0,W-1), xmax=clamp((x|0)+R,0,W-1);
  const ymin=clamp((y|0)-R,0,H-1), ymax=clamp((y|0)+R,0,H-1);


  ctx.clearRect(0,0,r.width,r.height);
  ctx.lineWidth=1;
  ctx.strokeStyle='rgba(210,214,230,.7)';
  ctx.beginPath();
  for(let yy=ymin; yy<=ymax; yy++){
    const dy=yy - y;
    for(let xx=xmin; xx<=xmax; xx++){
      const dx=xx - x;
      if(dx*dx + dy*dy < R*R/2){
        const sx = xx*cellW, sy = yy*cellH;
        ctx.strokeRect(Math.round(sx)+.5, Math.round(sy)+.5, Math.max(1,cellW-1), Math.max(1,cellH-1));
      }
    }
    console.log('---');
  }
  ctx.stroke();
}


function canvasToLocalPos(canvas,e){
  const rect=canvas.getBoundingClientRect();
  const sx=canvas.width/rect.width, sy=canvas.height/rect.height;
  var obj =  {x:(e.clientX-rect.left)*sx, y:(e.clientY-rect.top)*sy};
  obj.x=clamp(Math.floor(obj.x),0,canvas.width-1);
  obj.y=clamp(Math.floor(obj.y),0,canvas.height-1);
  return obj;
}

function handlePointerDown(canvas,e,domain){
  e.preventDefault();
  drawing=true; drawButton=e.button; activeCanvas=domain; activeCanvasEl=canvas;
  const {x,y}=canvasToLocalPos(canvas,e); lastMouse={x,y};
  hoverState={canvas,x,y,domain};
  refreshOverlayPreview();
  paintAt(x,y,domain,drawButton);
}

function clearHoverState(){
  hoverState={canvas:null,x:0,y:0,domain:null};
  octxImg.clearRect(0,0,overImg.width,overImg.height);
  octxFft.clearRect(0,0,overFft.width,overFft.height);
  octxPhase.clearRect(0,0,overPhase.width,overPhase.height);
}

function refreshOverlayPreview(){
  if(!hoverState.canvas) return;
  const {canvas,domain,x,y}=hoverState;
  let ctx, radius;
  if(domain==='image'){ ctx=octxImg; radius=brushSize; }
  else if(domain==='freq'){ ctx=octxFft; radius=brushSize; }
  else { ctx=octxPhase; radius=brushSize; }
  drawOverlay(ctx, canvas, radius, x, y);
}

function handlePointerMove(e){
  const t=e.target;
  if(t===canvImage || t===canvFreq || t===canvPhase){
    const {x,y}=canvasToLocalPos(t,e);
    const domain=t===canvImage?'image':(t===canvFreq?'freq':'phase');
    hoverState={canvas:t,x,y,domain};
    refreshOverlayPreview();
  }else{
    clearHoverState();
  }

  if(!drawing || !activeCanvas) return;
  const base=activeCanvasEl;
  const {x,y}=canvasToLocalPos(base,e);
  const dx=x-lastMouse.x, dy=y-lastMouse.y;
  const steps=Math.max(1, Math.ceil(Math.max(Math.abs(dx), Math.abs(dy))));
  for(let s=1;s<=steps;s++){
    const px=lastMouse.x+dx*s/steps, py=lastMouse.y+dy*s/steps;
    paintAt(px,py,activeCanvas,drawButton);
  }
  if(drawing && activeCanvas){
    hoverState={canvas:base,x,y,domain:activeCanvas};
    refreshOverlayPreview();
  }
  lastMouse={x,y};
}
function handlePointerUp(){
  if(!activeCanvas) return;
  drawing=false;
  if(activeCanvas==='image') flushImageSync();
  else flushFrequencySync();
  activeCanvas=null; activeCanvasEl=null;
}


function paintAt(x,y,domain,btn){
  if(domain==='image'){
    const delta=(btn===0)?deltaIntensity:-deltaIntensity;
    addCircleToArray(img,x,y,brushSize,delta/brushSize,0,225);
    renderImage();
    if(refreshMode==='draw') scheduleImageSync();
    else imgNeedsSync=true;
  }else if(domain==='freq'){
    const deltaLog=(btn===0)?deltaFrequency:-deltaFrequency;
    applyFrequencyBrushDelta(x,y,brushSize,deltaLog/brushSize);
    renderFreq();
    scheduleFrequencySync();
  }else{
    const deltaAngle=(btn===0)?deltaPhase:-deltaPhase;
    applyPhaseBrushDelta(x,y,brushSize, deltaAngle/brushSize);
    renderPhase();
    scheduleFrequencySync();
  }
}


function handleWheel(canvas,domain,e){
  e.preventDefault();
  const delta=Math.sign(e.deltaY);
  brushSize=clamp(brushSize - delta,1,120);
  brushSizeLabel.textContent=brushSize;
  const {x,y}=canvasToLocalPos(canvas,e);
  hoverState={canvas,x,y,domain};
  refreshOverlayPreview();
  saveSettings();
}


function wireCanvas(canvas,overlay,domain){
  canvas.addEventListener('contextmenu', e=>e.preventDefault());
  canvas.addEventListener('mousedown', e=>handlePointerDown(canvas,e,domain));
  canvas.addEventListener('wheel', e=>handleWheel(canvas,domain,e), {passive:false});
  canvas.addEventListener('mouseenter', e=>{
    const {x,y}=canvasToLocalPos(canvas,e);
    hoverState={canvas,x,y,domain};
    refreshOverlayPreview();
  });
  canvas.addEventListener('mouseleave', ()=>{clearHoverState();});
}
wireCanvas(canvImage, overImg, 'image');
wireCanvas(canvFreq,  overFft, 'freq');
wireCanvas(canvPhase, overPhase, 'phase');
window.addEventListener('mousemove', handlePointerMove, {passive:false});
window.addEventListener('mouseup', handlePointerUp);

let lastValidSize=W;

function triggerDimensionError(){
  sizeInput.classList.add('input-error');
  sizeInput.addEventListener('animationend', ()=>sizeInput.classList.remove('input-error'), {once:true});
  toast('Image size must be a power of two (32, 64, 128, ...).', 2200);
}

function applyDimensions(size){
  if(size===W) return; // square
  W=size;
  H=size;
  totalSize=W*H;
  lastValidSize=W;
  img=new Float64Array(W*H);
  re =new Float64Array(W*H);
  im =new Float64Array(W*H);
  mag=new Float64Array(W*H);
  magLog=new Float64Array(W*H);
  phase=new Float64Array(W*H);
  magShiftedLog=new Float64Array(W*H);
  phaseWrapped=new Float64Array(W*H);
  phaseShiftedDisplay=new Float64Array(W*H);
  freqNeedsSync=false;
  imgNeedsSync=false;
  if(freqSyncHandle!==null){ cancelAnimationFrame(freqSyncHandle); freqSyncHandle=null; }
  freqSyncScheduled=false;
  if(imgSyncHandle!==null){ cancelAnimationFrame(imgSyncHandle); imgSyncHandle=null; }
  imgSyncScheduled=false;
  disposeFft();
  forwardInputRows=null;
  freqConjRows=null;
  freqInputRows=null;
  setCanvasSize();
  clearToBlack();
  renderImage();
  forwardFromImage();
  brushSizeLabel.textContent=brushSize;
  if(sizeInput) sizeInput.value=String(W);
  // preserve existing phaseVisible state when resizing
  updatePhaseVisibility();
  clearHoverState();
  saveSettings();
}

function handleDimensionChange(){
  const newSize=parseInt(sizeInput.value,10);
  if(!Number.isFinite(newSize) || !isPow2(newSize)){
    triggerDimensionError();
    sizeInput.value=String(lastValidSize);
    return;
  }
  lastValidSize=newSize;
  applyDimensions(newSize);
}

sizeInput.addEventListener('change', handleDimensionChange);
sizeInput.addEventListener('input', ()=>sizeInput.classList.remove('input-error'));
let lastFocus=null;
function openHelp(){
  if(!helpModal) return;
  lastFocus=document.activeElement;
  helpModal.dataset.open='true';
  helpBtn?.setAttribute('aria-expanded','true');
  setTimeout(()=>{helpClose?.focus();},100);
  
  if(!hasSeenHelp) {
    hasSeenHelp = true;
    saveSettings();
  }
}
function closeHelp(){
  if(!helpModal) return;
  
  // Ensure hasSeenHelp is set when closing help
  if(!hasSeenHelp) {
    hasSeenHelp = true;
    saveSettings();
  }
  
  helpModal.dataset.open='false';
  helpBtn?.setAttribute('aria-expanded','false');
  setTimeout(()=>{
    if(lastFocus && typeof lastFocus.focus==='function') lastFocus.focus();
  }, 300);
}
helpBtn?.addEventListener('click', ()=>openHelp());
helpClose?.addEventListener('click', (e)=>{
  e.preventDefault();
  e.stopPropagation();
  closeHelp();
});
helpModal?.addEventListener('click', e=>{ if(e.target===helpModal) closeHelp(); });
window.addEventListener('keydown', e=>{ if(e.key==='Escape' && helpModal?.dataset.open==='true') { e.preventDefault(); closeHelp(); } });

window.addEventListener('resize', ()=>{ sizeOverlayFor(canvImage,overImg); sizeOverlayFor(canvFreq,overFft); sizeOverlayFor(canvPhase,overPhase); });
window.addEventListener('beforeunload', disposeFft);
window.addEventListener('unload', disposeFft);

(function init(){
  isInitializing = true; // Prevent saving during initialization
  
  const settings = loadSettings();
  
  brushSize = settings.brushSize;
  phaseVisible = settings.phaseVisible;
  hasSeenHelp = settings.hasSeenHelp;
  
  setTheme(settings.theme || 'light');
  updateBrushPower(settings.brushPower);
  setRefreshMode(settings.refreshMode);
  
  if (settings.canvasSize !== W) {
    applyDimensions(settings.canvasSize);
  } else {
    setCanvasSize();
    clearToBlack();
    renderImage();
    forwardFromImage();
  }
  
  updatePhaseVisibility();
  brushSizeLabel.textContent=brushSize;
  
  const themeToggle = document.getElementById('themeToggle');
  themeToggle?.addEventListener('click', toggleTheme);
    showWelcomeHelpIfFirstTime();

})();

</script>
</body>
</html>
